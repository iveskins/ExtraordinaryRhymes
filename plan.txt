Thus far:

1) Use Lettering.js to do word parsing and hovering. Hopefully it allows me to style the spans that surround each word.

http://stackoverflow.com/questions/6865714/highlight-an-individual-word-within-a-text-block-on-hover

http://letteringjs.com/

2) Use ECMAScript 6 classes to create song blocks and structures (i.e. verse, chorus, hook, bridge, intro, and so on) and have these classes have methods that work on themselves. We don't want phrases to rhyme outside of themselves.

Interesting thought: the abstraction of the song must (is) match the literal representation of the song. In other words, how the song is represented theoretically (in code), must somehow match what the song "actually is." This is not just abstract or helpful, but is the most practical way to actually go about it, and thus, the easiest way.

This was counterintuitive to me because I initially thought it would be easier to write a program that didn't actually do that thing ("edit song lyrics"), but rather did work to make it appear like it did that thing. But the best way to write an app that actually edited song lyrics would be to have an app that actually edited song lyrics, and this would be accomplished via having the code actually "be" song lyrics.

In other words the program doesn't "do" anything, it "is" the thing that it's editing. It's the legit thing, it's actually editing song lyrics (because the program is made of song lyrics).

A good explication of what I'm saying is related to how I had the app set up: initially it was a script attached to a web page that parsed text and would search for rhymes via an API. But upon digging into this more, and thus "biting off more than I could chew," I discovered that it would be easier to edit the lyrics if I wrote classes for objects that represented different parts of the song. Thus, the literal, and the representation, are the same. There is no distinction. Nonduality. Enlightenment. Blah, blah blah.
